(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{352:function(e,a,t){"use strict";t.r(a);var s=t(3),l=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("boolean autoAck = false;\nchannel.basicConsum(QUEUE_NAME, autoAck, consumer)\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("blockquote",[t("p",[e._v("boolean autoAck = true;")])]),e._v(" "),t("p",[e._v("自动确认模式，一旦rabbitmq将消息分发给消费者，就会从内存中删除；若正在消费的消费者被kill，就会丢失正在处理的消息")]),e._v(" "),t("blockquote",[t("p",[e._v("boolean autoAck = false;")])]),e._v(" "),t("p",[e._v("手动模式，如果消费者处理过程中挂掉，就会交付给其他消费者消费，rabbitmq支持消息应答，消费者发送消息应答给rabbitmq，告知消息处理完，此时rabbitmq就会删除内存中的消息；")]),e._v(" "),t("blockquote",[t("p",[e._v("消息应答默认是打开的")])]),e._v(" "),t("p",[e._v("一旦rabbitmq挂了，内存中的消息仍然会丢失，此时就需要持久化功能。")]),e._v(" "),t("blockquote",[t("p",[e._v("rabbitmq支持持久化.")])]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('boolean durable = false;\nchannel.queueDeclare("work_queue", durable, false,false, null);\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("队列声明后，rabbitmq不允许重新定义（不同参数）一个已存在的队列，因此需要在第一次声明队列时指定参数")])])}),[],!1,null,null,null);a.default=l.exports}}]);